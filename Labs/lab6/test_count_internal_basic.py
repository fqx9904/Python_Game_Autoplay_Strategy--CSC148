import unittest
import random
from hypothesis import given
from hypothesis import note
from hypothesis.strategies import integers
from hypothesis.strategies import lists
from hypothesis.strategies import recursive
from ex6 import count_internal


def make_children_list(children):
    """
    Return a list of child Trees generated by children.

    @param list[object]|object children: The children values and trees
    @rtype: (list[Tree], int)
    """
    num_internal = 0
    if type(children) != list:
        return [[Tree(children)], 0]

    ret_children = []
    for child in children:
        if type(child) == list:
            rec_call = make_children_list(child)
            ret_children.append(Tree(random.randint(0, 100), rec_call[0]))

            if rec_call[0]:
                num_internal += 1

            num_internal += rec_call[1]
        else:
            rec_call = make_children_list(child)
            ret_children += rec_call[0]
            num_internal += rec_call[1]

    # Pick a random value for the Tree's value
    return (ret_children, num_internal)


class Tree:
    """
    A bare-bones Tree ADT that identifies the root with the entire tree.
    """
    def __init__(self, value=None, children=None):
        """
        Create Tree self with content value and 0 or more children

        @param Tree self: this tree
        @param object value: value contained in this tree
        @param list[object|None] children: possibly-empty list of children
        @rtype: None
        """
        self.value = value
        # copy children if not None
        self.children = children.copy() if children else []

    def __repr__(self):
        """
        Return representation of Tree (self) as string that
        can be evaluated into an equivalent Tree.

        @param Tree self: this tree
        @rtype: str

        >>> t1 = Tree(5)
        >>> t1
        Tree(5)
        >>> t2 = Tree(7, [t1])
        >>> t2
        Tree(7, [Tree(5)])
        """
        # Our __repr__ is recursive, because it can also be called
        # via repr...!
        return ('Tree({}, {})'.format(repr(self.value), repr(self.children))
                if self.children
                else 'Tree({})'.format(repr(self.value)))


class CountInternalTests(unittest.TestCase):
    def test_returns_int(self):
        """
        Test count_internal to make sure it returns an int.
        """
        return_type = type(count_internal(Tree(0, [Tree(1, [Tree(2)])])))
        self.assertEqual(return_type, int, "count_internal should return type" +
                         "int, but instead returned type {}.".format(return_type
                                                                     ))

    def test_leaf_node(self):
        """
        Test count_internal on a leaf node.
        """
        self.assertEqual(count_internal(Tree(0)), 0, "Leaf nodes should " +
                         "have 0 internal nodes.")

    def test_one_leaf_child(self):
        """
        Test count_internal on a tree containing only a root and its leaf child.
        """
        t = Tree(0, [Tree(1)])

        self.assertEqual(count_internal(t), 1, "Leaf nodes should not be " +
                         "included in the count, while root nodes (with " +
                         "children) should.")

    def test_multiple_leaf_children(self):
        """
        Test count_internal on a tree containing only a root and its children
        which are all leaves.
        """
        t = Tree(0, [Tree(1), Tree(2)])

        self.assertEqual(count_internal(t), 1, "Leaf nodes should not be " +
                         "included in the count, while root nodes (with " +
                         "children) should.")

    def test_multiple_non_leaf_children(self):
        """
        Test count_internal on a tree containing only a root and its children
        which are all subtrees with children.
        """
        t = Tree(0, [Tree(1, [Tree(3), Tree(5)]), Tree(2, [Tree(4), Tree(6)])])

        self.assertEqual(count_internal(t), 3, "All non-leaf nodes should be " +
                         "counted as an internal node.")

    @given(integers(min_value = -99, max_value = 99),
           recursive(integers(min_value = -99, max_value = 99), lists,
                     max_leaves = 20))
    def test_count_internal(self, value, children):
        """
        Test the correctness of count_internal against the solution.
        """
        (children_list, num_internal) = make_children_list(children)
        t = Tree(value, children_list)

        if children_list:
            num_internal += 1
        actual = count_internal(t)
        self.assertEqual(actual, num_internal,
                         ("count_internal on the Tree\n{}\nReturned {}" +
                          " instead of {}.").format(t.__repr__(), actual,
                                                   num_internal))


if __name__ == "__main__":
    unittest.main()
